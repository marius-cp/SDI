% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/asyfuns.R
\name{asy_var_dm}
\alias{asy_var_dm}
\title{Calculate variance of the decomposition components for two (rival) forecasts based on Mincer-Zarnowitz regressions.}
\usage{
asy_var_dm(X_1, X_2, Y, S, V, Spp, vcov_estimator = sandwich::vcovHAC)
}
\arguments{
\item{X_1}{Numeric vector  for the first forecast.}

\item{X_2}{Numeric vector for the second forecast.}

\item{Y}{Numeric vector for the outcome variable.}

\item{S}{Function, the scoring function used to assess the forecasts.}

\item{V}{Function, the identification function, where V is the derivative of S.}

\item{Spp}{Function, second derivative of the scoring function, default is NA.}

\item{vcov_estimator}{Function, variance-covariance estimator from the sandwich package.}
}
\value{
A list containing several components:
  - `asy_vars`: a data frame with the variances of s, mcb, and dsc for both forecasts.
  - `pvals`: p-values for testing the significance of differences.
  - `Lambda`: matrix used in the variance calculations.
  - `temp_Omega`: raw matrix of a_{1,t}, ..., e_t that is used to estimat cov matrix
  - `Omega`: covariance matrix based on the scoring function.
  - `eta`: transformation matrix used in variance calculations.
  - `Gamma`: product of eta and Lambda matrices.
  - `dec_1`: decomposition results for the first forecast.
  - `dec_2`: decomposition results for the second forecast.
}
\description{
This function computes variance of the score decomposition for two rival forecasts X_1 and X_2
based on the provided data. It calculates components related to the score (s), miscalibration (mcb), and discrimination (dsc).
}
\details{
It can happen that a) covariance matrix estimation fails or b) the
determinat is not meaningful. We check for b) with `det(Omega) <= 10^(-50)`.
In any of the two cases the `Omega` output is a 5x5 matrix of `NaN` values.
The p-values are set to 1 in this case to facilitate conservative test decisions.
}
\examples{
# Define a simple scoring function
S <- function(y, x) { (y - x)^2 }
# Define its derivative
V <- function(x, y) { 2 * (y - x) }
Spp = function(x, y) 2
# Generate sample data
Y <- rnorm(100)
X_1 <- Y + rnorm(100, sd = 0.5)
X_2 <- Y + rnorm(100, sd = 0.5)
# Calculate asymmetric variance
results <- asy_var_dm(X_1, X_2, Y, S, V, Spp)
print(results)

}
